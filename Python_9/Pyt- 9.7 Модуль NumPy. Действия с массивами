ДЕЙСТВИЯ С МАССИВАМИ
ИЗМЕНЕНИЕ ФОРМЫ МАССИВА

Создадим массив из восьми чисел:
import numpy as np
arr = np.arange(8)
arr
# array([0, 1, 2, 3, 4, 5, 6, 7])

Поменять форму массива arr можно с помощью присвоения атрибуту shape кортежа с желаемой формой:
arr.shape = (2, 4)
arr
# array([[0, 1, 2, 3],
#        [4, 5, 6, 7]])

Чтобы оставить исходный массив без изменений и дополнительно получить новый массив новой формы, нужно использовать функцию reshape.
arr = np.arange(8)
arr_new = arr.reshape((2, 4))
arr_new
# array([[0, 1, 2, 3],
#       [4, 5, 6, 7]])

У функции reshape есть дополнительный именованный аргумент order. Если order='C' (по умолчанию), массив заполняется по строкам. Если order='F', массив заполняется числами по столбцам:
arr = np.arange(8)
arr_new = arr.reshape((2, 4), order='F')
arr_new
# array([[0, 2, 4, 6],
#       [1, 3, 5, 7]])

Ф-я транспонирование. Эта операция меняет строки и столбцы массива местами. В NumPy эту операцию совершает функция transpose.
Будем работать с двумерным массивом:
arr = np.arange(8)
arr.shape = (2, 4)

Транспонируем его:
arr_trans = arr.transpose()
arr_trans
# array([[0, 4],
#        [1, 5],
#        [2, 6],
#        [3, 7]])

! При транспонировании одномерного массива его форма не меняется:

ИНДЕКСЫ И СРЕЗЫ В МАССИВАХ

Создадим массив из шести чисел:
arr = np.linspace(1, 2, 6)
arr
# array([1. , 1.2, 1.4, 1.6, 1.8, 2. ])

Обратиться к его элементу по индексу можно так же, как и к списку:
print(arr[2])
# 1.4

Привычная запись для срезов работает и для одномерных массивов:
print(arr[2:4])
# [1.4 1.6]

Наконец, напечатать массив в обратном порядке можно с помощью привычной конструкции [::-1]:
print(arr[::-1])
# [2.  1.8 1.6 1.4 1.2 1. ]

Создадим двумерный массив из одномерного:
nd_array =  np.linspace(0, 6, 12, endpoint=False).reshape(3,4)
nd_array
# array([[0. , 0.5, 1. , 1.5],
#        [2. , 2.5, 3. , 3.5],
#        [4. , 4.5, 5. , 5.5]])

Можно воспользоваться привычной записью нескольких индексов в нескольких квадратных скобках:
nd_array[1][2]
ИЛИ
nd_array[1, 2]
# 3.0

Также через запятую можно передавать срезы или даже их комбинации с индексами. Например, получим все элементы из колонки 3 для первых двух строк:
nd_array[:2, 2]
# array([1., 3.])

Можно применять срезы сразу и к строкам, и к столбцам:
nd_array[1:, 2:4]
# array([[3. , 3.5],
#       [5. , 5.5]])

Чтобы получить все значения из какой-то оси, можно оставить на её месте двоеточие. Например, из всех строк получим срез с третьего по четвёртый столбцы:
nd_array[:, 2:4]
# array([[1. , 1.5],
#       [3. , 3.5],
#       [5. , 5.5]])

Чтобы получить самую последнюю ось (в данном случае все столбцы), двоеточие писать необязательно. Строки будут получены целиком по умолчанию:
nd_array[:2]
# array([[0. , 0.5, 1. , 1.5],
#       [2. , 2.5, 3. , 3.5]])

СОРТИРОВКА ОДНОМЕРНЫХ МАССИВОВ
Способ 1. Функция np.sort(<массив>) возвращает новый отсортированный массив:
arr = np.array([23,12,45,12,23,4,15,3])
arr_new = np.sort(arr)
print(arr)
# [23 12 45 12 23  4 15  3]
print(arr_new)
# [ 3  4 12 12 15 23 23 45]

Способ 2. Функция <массив>.sort() сортирует исходный массив и возвращает None:
arr = np.array([23,12,45,12,23,4,15,3])
print(arr.sort())
# None
print(arr)
# [ 3  4 12 12 15 23 23 45]

РАБОТА С ПРОПУЩЕННЫМИ ДАННЫМИ
data = np.array([4, 9, -4, 3])
Воспользуемся встроенной в NumPy функцией sqrt, чтобы посчитать квадратные корни из элементов.
roots = np.sqrt(data)
roots
# RuntimeWarning: invalid value encountered in sqrt
# array([2.        , 3.        ,        nan, 1.73205081])
NumPy выдал предупреждение о том, что в функцию sqrt попало некорректное значение. Это было число -4, а как вы помните, корень из отрицательного числа в действительных числах не берётся
На том месте, где должен был оказаться корень из -4, теперь присутствует объект nan. Он расшифровывается как Not a number (не число). Этот объект аналогичен встроенному типу None, но имеет несколько отличий:
Отличие 1. None является отдельным объектом типа NoneType. np.nan — это отдельный представитель класса float:
print(type(None))
# <class 'NoneType'>
print(type(np.nan))
# <class 'float'>
type(np.nan)
Отличие 2. None могут быть равны друг другу, а np.nan — нет:
print(None == None)
# True
print(np.nan == np.nan)
# False
Как вы помните, чтобы грамотно сравнить что-либо с None, необходимо использовать оператор is. Это ещё более актуально для np.nan. Однако None даже через is не является эквивалентным np.nan:
print(None is None)
# True
print(np.nan is np.nan)
# True
print(np.nan is None)
# False


Можно заполнить пропущенные значения, например, нулями. Для этого с помощью функции np.isnan(<массив>) узнаем, на каких местах в массиве находятся «не числа»:
np.isnan(roots)
# array([False, False,  True, False])
Можно использовать полученный массив из True и False для извлечения элементов из массива roots, на месте которых в булевом массиве указано True. Таким способом можно узнать сами элементы, которые удовлетворяют условию np.isnan:
roots[np.isnan(roots)]
# array([nan])
Этим элементам можно присвоить новые значения, например 0:
roots[np.isnan(roots)] = 0
roots
# array([2.        , 3.        , 0.        , 1.73205081])
После этого, если пропущенных значений больше нет, можем подсчитать сумму элементов массива:
sum(roots)
# 6.732050807568877

